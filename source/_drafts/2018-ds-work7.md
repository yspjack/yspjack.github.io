---
title: 2018-ds-work7
tags:
---

## 单词查找（查找-基本题）

从标准输入中读入一个英文单词及查找方式，在一个给定的英文常用单词字典文件  {% asset_link dictionary3000.txt dictionary3000.txt %}  中查找该单词，返回查找结果（**查找到返回1，否则返回0**）和**查找过程中单词的比较次数**。查找前，先将所有字典中单词读入至一个单词表（数组）中，然后按要求进行查找。字典中单词总数不超过3500，单词中的字符都是英文小写字母，并已按字典序排好序。字典中的单词和待查找单词的**字符个数不超过20**。

查找方式说明：查找方式以1~4数字表示，每个数字含义如下：

1：在单词表中以顺序查找方式查找，因为单词表已排好序，遇到**相同的或第一个比待查找的单词大的单词，就要终止查找**；

2：在单词表中以折半查找方式查找；

3：在单词表中通过索引表来获取单词查找范围，并**在该查找范围中以折半方式查找**。索引表构建方式为：以26个英文字母为头字母的单词在字典中的起始位置和单词个数来构建索引表，如：

|字母|起始位置|单词个数|
|-|-|-|
|a|0|248|
|b|248|167|
|…|…|…|

该索引表表明以字母a开头的单词在单词表中的开始下标位置为0，单词个数为248。

4：按下面给定的hash函数为字典中单词构造一个hash表，hash冲突时按字典序依次存放单词。hash查找遇到冲突时，采用链地址法处理，**在冲突链表中找到或未找到(遇到第一个比待查找的单词大的单词或链表结束)便结束查找**。

```C
/* compute hash value for string */
#define NHASH  3001
#define MULT  37
unsigned int hash(char *str)
{
       unsigned int h=0;
       char *p;
       for(p=str; *p!='\0'; p++)
              h = MULT*h + *p;
       return h % NHASH;
}
```

提示：hash表可以构建成指针数组，hash冲突的单词形成一有序链表。

<!--more-->

### 输入形式

单词字典文件dictionary3000.txt存放在当前目录下，待查找单词和查找方式从标准输入读取。待查找单词只包含英文小写字母，与表示查找方式的整数之间以一个空格分隔。

### 输出形式

将查找结果和单词比较次数输出到标准输出上，两整数之间以一个空格分隔。

### 样例输入与输出

单词字典文件dictionary3000.txt与下载中提供的相同，下面两列中，左侧为待查找单词与查找方式，右侧为对应的输出结果：

|输入|输出|
|-|-|
|wins 1| 0 3314|
|wins 2| 0 12|
|wins 3| 0 7|
|wins 4| 0 2|
|yes 1| 1 3357|
|yes 2| 1 10|
|yes 3| 1 4|
|yes 4| 1 1|

### 样例说明

wins在单词字典中不存在，4种查找方式都输出结果0，顺序查找、折半查找、索引查找和hash查找的单词比较次数分别为：3314、12、7和2次（wins的hash位置与字典中physics和suggest相同）。

yes在单词字典中存在，4种查找方式都输出结果1，顺序查找、折半查找、索引查找和hash查找的单词比较次数分别为：3357、10、4和1。

### 评分标准

该题要求输出查找结果和查找过程中的单词比较次数，提交程序名为find.c。

## 整数排序（排序-基本题）

从标准输入中输入一组互不相同的整数（个数不超过100）及排序方式，按照从小到大排序，输出按某种算法排序的结果及元素的比较次数。

说明：排序方式为一个1~5的整数，分别表示：

1：选择排序，比较次数是指选择未排序部分的最小元素时的比较次数。

2：冒泡排序，比较次数是指相邻元素的比较次数，**若某趟排序中没有进行数据交换**，就认为排序结束。

3：堆排序，比较次数是指根元素调整过程中根元素与子树根结点的比较次数：

```C
void adjust(int k[ ],int i,int n)
{
    int j,temp;
    temp=k[i];
    j=2*i+1;
    while(j<n){
        if(j<n-1 && k[j]<k[j+1])
            j++;
        if(temp>=k[j]) // 计算这里的比较次数
           break;
        k[(j-1)/2]=k[j];
        j=2*j+1;
    }
    k[(j-1)/2]=temp;
}
```

4：二路归并排序，比较次数是指两组有序数据合并成一组时的比较次数：

```C
void merge(int x[ ],int tmp[ ],int left,int leftend,int rightend)
{
    int i=left, j=leftend+1, q=left;
    while(i<=leftend && j<=rightend)
    {
        if(x[i]<=x[j]) // 计算这里的比较次数
            tmp[q++]=x[i++];
        else
            tmp[q++]=x[j++];
    }

    while(i<=leftend)
        tmp[q++]=x[i++];

    while(j<=rightend)
        tmp[q++]=x[j++];

    for(i=left; i<=rightend; i++)
        x[i]=tmp[i];

}
```

5：快速排序，比较次数是指分界元素与其它元素的比较次数：

```C
void quickSort(int k[ ],int left,int right)
{
    int i, last;
    if(left<right){
        last=left;
        for(i=left+1;i<=right;i++)
            if(k[i]<k[left]) // 计算这里的比较次数
                swap(&k[++last],&k[i]);
        swap(&k[left],&k[last]);
        quickSort(k,left,last-1);
        quickSort(k,last+1,right);
    }
}
```

### 输入形式

首先在屏幕上输入2个整数，分别表示待排序的整数个数及排序方式，然后在下一行依次输入待排序的整数。各整数之间都以一个空格分隔。

### 输出形式

先在一行上输出排序结果，各整数间以一个空格分隔。然后在下一行上输出排序过程中的元素比较次数。

### 样例1输入

```C
20 1
38 356 98 -102 126 46 65 -9 100 0 21 2 90 8 18 12 78 16 189 23
```

### 样例1输出

```C
-102 -9 0 2 8 12 16 18 21 23 38 46 65 78 90 98 100 126 189 356
190
```

### 样例1说明

输入了20个整数数据，要求按照选择排序算法对输入的数据进行从小到大排序，输出排序结果，排序过程中元素的比较次数为190次。

### 其它样例说明

若输入的待排序数据与样例1完全相同，要求的排序算法不同，则输出的排序结果与样例1完全一样，但比较次数不同，为了方便说明，下面左侧为排序方式，右侧为对应的比较次数：
2            162
3            58
4            66
5            75

### 评分标准

该题要求按照指定算法对输入的数据进行排序，提交程序名为sort.c。
