---
title: 2017级程设基础训练第二次上机
date: 2017-10-29 12:00:00
mathjax: true
tags: C
---

## A 一起来做函数题

### Description

$$y =
\begin{cases}
x &(x<1) \\
2x-3 &(1\le x < 10)\\
3x - 5 &(10\le x)
\end{cases}$$

### Hint

``` cpp
#include <iostream>
using namespace std;
int main()
{
	int x;
	cin>>x;
	if(x<1)
		cout<<x<<endl;
	else if(x<10)
		cout<<2*x-3<<endl;
	else
		cout<<3*x-5<<endl;
	return 0;
}
```

<!--more-->

## B 交换生资格审核

### 题目描述

北京仰望星空大学拥有一些针对大二学生的与国外大学进行交流的交换项目，报名的学生很多，但是只有达到一定要求的人才能通过初审，要求如下：对于三好学生要求GPA不低于3.5或大一上、下两学期平均分均（仅包含数学分析、离散数学、体育三科）均不低于80，对于非三好学生要求GPA不低于3.6或大一上、下两学期平均分均超过85。面对如此多份的交换申请，负责审核的王老师很是苦恼，请你帮助他设计一个程序检查某位申请交换的学生是否符合条件。

### 输入

三行数据，第一行为该生是否为三好学生（是为1，否为0）(整型)和GPA(浮点型)，接下来两行分别为参加审核的学生大一上、下两学期学期的成绩(均为整型)：数学分析、离散数学、体育。每行数据之间用空格分开

### 输出

输出该生初审结果（通过输出APPROVED，未通过输出REJECTED）

### 输入样例

```
0 3.57
82 86 90
88 86 85
```

### 输出样例

```
APPROVED
```

### Hint

``` c
#include <string.h>
#include <stdio.h>

int main()
{
    int f;
    double gpa;
    int a1,b1,c1,a2,b2,c2;
    scanf("%d%lf%d%d%d%d%d%d",&f,&gpa,&a1,&b1,&c1,&a2,&b2,&c2);

    if(f)
    {
        if(gpa>=3.5 || (((double)a1+b1+c1)/3>=80.0 && ((double)a2+b2+c2)/3>=80.0))
            puts("APPROVED");
        else
            puts("REJECTED");
    }
    else
    {
        if(gpa>=3.6 || (((double)a1+b1+c1)/3>85.0 && ((double)a2+b2+c2)/3>85.0))
            puts("APPROVED");
        else
            puts("REJECTED");
    }
    return 0;
}
```

## C 韩主席来发夜宵啦

### 题目描述

韩主席拜托他的好哥哥ys同学出一道有他上镜的题，于是就有了这道题：

某天夜里17级的萌新们在三公寓楼下站成一排等待韩主席和ly姐姐发狗粮，最左边的同学编号为L，最右边的同学编号为R，编号为连续的正整数。（左数第一位为L，第二位为L+1，第三位为L+2，……倒数第二位为R-1，最后一位为R）

现在韩主席选择一个数X，他要给所有编号为X的倍数的同学发狗粮。请你帮他选择一个数，使得他能够尽可能多的给同学们发狗粮。（由于单身狗的愤怒你不能选择X为1）

### 输入

两个正整数L，R($1< L \le R \le 10^9$)

### 输出

一个正整数X（若同时有多个X使得条件成立，输出最小的那个）
当两个正整数相同时就输出这个数本身

### 输入样例

```
4 10
```

### 输出样例

```
2
```

### Hint

``` c
#include <stdio.h>

int main()
{
    int L,R;
    scanf("%d%d",&L,&R);
    printf("%d\n",(L!=R)?2:L);
    return 0;
}
```

## D 成双成对的尾巴

### 题目描述

 一个数的阶乘尾巴总是会有很多0，如果0的个数是偶数的话，我们认为它是美观的，因为它的尾巴是成双成对的。 ​所有$0！，1！，2！... ... (n-1)!，n!$中有多少数的尾巴0的个数是偶数。

### 输入

输入1个数N $(1 \le N \le 24)$ 。

### 输出

输出为$0！，1！，2！......(n−1)!，n!$
中尾巴的0的个数是偶数的个数。

### 输入样例

```
1
```

### 输出样例

```
2
```

### Hint

``` c
#include <stdio.h>
#include <string.h>

int main()
{
	int L,ans=0;
	scanf("%d",&L);
	if(L<=4)
		ans=L+1;
	else if(L<=9)
		ans=5;
	else if(L<=14)
		ans=L+1-5;
	else if(L<=19)
		ans=10;
	else
		ans=L+1-5-5;
	printf("%d\n",ans);
	return 0;
}
```

## E QZZ的世界观测

### 题目描述

QZZ有个名为百里木明的好友。百里木明是世界管理局的观察者，经常需要在世界壁上打开窗口进行观测。观测是一件相当无聊的事情，百里木明想到可以在大窗口里再放两个窗口以提高效率……对于给定的窗口，百里木明想知道能不能这样做，不过他懒得算，于是把问题丢给了QZZ，QZZ觉得这太简单了，就把问题丢给了你。

示意图：
{% asset_img 897-1.jpg%}

现在给出百里木明拥有的3个矩形窗口，请你判断这3个窗口可以像上面这张图一样,一个套两个,可以则输出“SIXSIXSIX!”，否则输出“GG!”。

注意:

1．大窗口内的两个小窗口不能重叠,比如下面的情况是不可以的。
{% asset_img 898-2.jpg%} {% asset_img 898-3.jpg%}
2．内窗口的边应与外窗口的边平行，即内窗口不可以斜放,如下图是不可以的。
{% asset_img 898-4.jpg%}
3．窗口的边可以重叠。
4．允许小窗口旋转90度后放到大窗口中。

### 输入

共三行，每行两个正整数，表示每个矩形窗口的两个相临边的边长。(长宽都小于等于1000)

### 输出

输出对应字符串

### 输入样例1

```
30 30
8 9
5 10
```

### 输出样例1

```
SIXSIXSIX!
```

### 输入样例2

```
8 9
5 10
10 5
```

### 输出样例2

```
GG!
```

### Hint

``` cpp
#include <iostream>
#include <algorithm>
using namespace std;
struct Window
{
    int x,y;
} w[3];
int main()
{
    for(int i=0; i<3; i++)
        cin>>w[i].x>>w[i].y;
    sort(w,w+3,[](const Window&a,const Window&b){return a.x*a.y>b.x*b.y;});
    int f=0;
    if(max(w[1].y,w[2].y)<=w[0].y && w[1].x+w[2].x<=w[0].x)f=1;
    if(max(w[1].x,w[2].y)<=w[0].y && w[1].y+w[2].x<=w[0].x)f=1;
    if(max(w[1].y,w[2].x)<=w[0].y && w[1].x+w[2].y<=w[0].x)f=1;
    if(max(w[1].x,w[2].x)<=w[0].y && w[1].y+w[2].y<=w[0].x)f=1;
    if(max(w[1].y,w[2].y)<=w[0].x && w[1].x+w[2].x<=w[0].y)f=1;
    if(max(w[1].x,w[2].y)<=w[0].x && w[1].y+w[2].x<=w[0].y)f=1;
    if(max(w[1].y,w[2].x)<=w[0].x && w[1].x+w[2].y<=w[0].y)f=1;
    if(max(w[1].x,w[2].x)<=w[0].x && w[1].y+w[2].y<=w[0].y)f=1;
    cout<<(f?"SIXSIXSIX!":"GG!")<<endl;
    return 0;
}
```