---
title: 数据结构第6次作业（树）
tags:
---
## 树叶节点遍历（树-基础题）

### 问题描述

从标准输入中输入一组整数，在输入过程中按照左子结点值**小于**根结点值、右子结点值**大于等于**根结点值的方式构造一棵二叉查找树，然后从左至右输出所有树中叶结点的值及高度（根结点的高度为1）。例如，若按照以下顺序输入一组整数：50、38、30、64、58、40、10、73、70、50、60、100、35，则生成下面的二叉查找树：

{% asset_img 149371235786007402449.png %}

从左到右的叶子结点包括：10、35、40、50、60、70、100，叶结点40的高度为3，其它叶结点的高度都为4。

### 输入形式

先从标准输入读取整数的个数，然后从下一行开始输入各个整数，整数之间以一个空格分隔。

### 输出形式

按照从左到右的顺序分行输出叶结点的值及高度，值和高度之间以一个空格分隔。

### 样例输入

```
13
50 38 30 64 58 40 10 73 70 50 60 100 35
```

### 样例输出

```
10 4
35 4
40 3
50 4
60 4
70 4
100 4
```

### 样例说明

按照从左到右的顺序输出叶结点（即没有子树的结点）的值和高度，每行输出一个。

### 评分标准

该题要求输出所有叶结点的值和高度，提交程序名为：`bst.c`

## 在家谱中查找关系远近

### 问题描述

同姓氏中国人见面常说的一句话是“我们五百年前可能是一家”。从当前目录下的文件`in.txt`中读入一家谱，从标准输入读入两个人的名字（两人的名字肯定会在家谱中出现），编程查找判断这两个人相差几辈，若同辈，还要查找两个人共同的最近祖先以及与他（她）们的关系远近。假设输入的家谱中**每人最多有两个孩子**，例如下图是根据输入形成的一个简单家谱：

{% asset_img 14899742853770939574249.jpg %}

通过该家谱，可以看到wangliang、wangguoping和wangguoan都有两个孩子，wangtian、wangxiang和wangsong有一个孩子，wangguang、wangqinian、wangping和wanglong还没有孩子。若要查找的两个人是wangqinian和wangguoan，从家谱中可以看出两人相差两辈；若要查找的两个人是wangping和wanglong，可以看出两人共同的最近祖先是wangguoan，和两人相差两辈。

### 输入形式

从当前目录下的`in.txt`中读入家谱。文件中第一行是家谱中有孩子的人数，后面每行内容是每个人的名字和其孩子的名字，名字都由1到20个英文字母构成，各名字间以一个空格分隔，整个家谱中的人员都**不会重名**；若只有一个孩子，则第二个孩子的名字为`NULL`；若没有孩子，则不需输入；输入的顺序是按照**辈份从高到低**依次输入，若孩子A出现在孩子B之前，则A的孩子应在B的孩子之前输入。假设以该形式读入的家谱肯定能够形成类似上图所示的一棵二叉树形式的家谱，家谱中任何两人相差的辈份不会超过100。

从标准输入读入要查找的两个人的名字，两名字间也以一个空格分隔。

### 输出形式

所有信息输出到标准输出上。

若要查找的两人不同辈，则**先输出辈份低的名字**，再输出辈份高的名字，然后输出相差几辈，都以一个空格分隔；

若两人同辈，按照两人名字从标准输入读取的先后顺序，分行输出两人的最近祖先名字、两人姓名以及相差几辈，各数据间以一个空格分隔。

### 样例1输入

假设当前目录下`in.txt`文件内容为：

```
6
wangliang wangguoping wangguoan
wangguoping wangtian wangguang
wangguoan wangxiang wangsong
wangtian wangqinian NULL
wangxiang wangping NULL
wangsong wanglong NULL
```

从标准输入读取：

```
wangqinian wangliang
```

### 样例1输出

```
wangqinian wangliang 3
```

### 样例1说明

家谱中输入了六个人名及其孩子的人名，形成了“问题描述”中的家谱，要查找的两人是`wangqinian`和`wangliang`，`wangliang`比`wangqinian`高3辈。

### 样例2输入

假设当前目录下`in.txt`文件内容为：

```
6
wangliang wangguoping wangguoan
wangguoping wangtian wangguang
wangguoan wangxiang wangsong
wangtian wangqinian NULL
wangxiang wangping NULL
wangsong wanglong NULL
```

从标准输入读取：

```
wangping wanglong
```

### 样例2输出

```
wangguoan wangping 2
wangguoan wanglong 2
```

### 样例2说明

和样例1同样输入了一家谱，`wangping`和`wanglong`共同的最近祖先是`wangguoan`，该祖先与两人相差两辈。

### 评分标准

该程序要求在家谱中查找判断两人的关系远近，提交程序文件名为`find.c`。

## 词频统计（树实现）

### 问题描述

编写程序统计一个英文文本文件中每个单词的出现次数（词频统计），并将统计结果按单词字典序输出到屏幕上。

要求：程序应用二叉排序树（BST）来存储和统计读入的单词。

注：在此单词为仅由字母组成的字符序列。包含大写字母的单词应将大写字母转换为小写字母后统计。**生成二叉排序树不做平衡处理**。

### 输入形式

打开当前目录下文件`article.txt`，从中读取英文单词进行词频统计。

### 输出形式

程序应首先输出二叉排序树中根节点、根节点的右节点及根节点的右节点的右节点上的单词（即`root`、`root->right`、`root->right->right`节点上的单词），单词中间有一个空格分隔，最后一个单词后没有空格，直接为回车（若单词个数不足三个，则按实际数目输出）。

程序将单词统计结果按单词字典序输出到屏幕上，每行输出一个单词及其出现次数，单词和其出现次数间由一个空格分隔，出现次数后无空格，直接为回车。

### 样例输入

当前目录下文件`article.txt`内容如下：

```
"Do not take to heart every thing you hear."
"Do not spend all that you have."
"Do not sleep as long as you want;"
```

### 样例输出

```
do not take
all 1
as 2
do 3
every 1
have 1
hear 1
heart 1
long 1
not 3
sleep 1
spend 1
take 1
that 1
thing 1
to 1
want 1
you 3
```

### 样例说明

程序首先在屏幕上输出程序中二叉排序树上根节点、根节点的右子节点及根节点的右子节点的右子节点上的单词，分别为`do not take`，然后按单词字典序依次输出单词及其出现次数。

### 评分标准

通过全部测试点得满分

## Huffman编码文件压缩

### 问题描述

编写一程序采用Huffman编码对一个正文文件进行压缩。具体压缩方法如下：

1. 对正文文件中字符(换行字符'\n'除外，不统计)按出现次数（即频率）进行统计
2. 依据字符频率生成相应的Huffman树（未出现的字符不生成）
3. 依据Huffman树生成相应字符的Huffman编码
4. 依据字符Huffman编码压缩文件（即按照Huffman编码依次输出源文件字符）。

说明：

1. 只对文件中出现的字符生成Huffman，注意：一定不要处理`\n`，即不要为其生成Huffman码。
2. 采用ASCII码值为0的字符作为压缩文件的结束符（即可将其出现次数设为1来参与编码）.
3. 在生成Huffman树时，初始在对字符频率权重进行（由小至大）排序时，频率相同的字符ASCII编码值小的在前；新生成的权重节点插入到有序权重序列中时，出现相同权重时，插入到其后（采用稳定排序）。
4. 遍历Huffman树生成字符Huffman码时，左边为0右边为1。
5. 源文件是文本文件，字符采用ASCII编码，每个字符占8位；而采用Huffman编码后，高频字符编码长度较短（小于8位），因此最后输出时需要使用C语言中的位运算将字符Huffman码依次输出到每个字节中。

### 输入形式

对当前目录下文件`input.txt`进行压缩。

### 输出形式

将压缩后结果输出到文件`output.txt`中，同时将压缩结果用十六进制形式（`printf("%x",...)`）输出到屏幕上，以便检查和查看结果。

### 样例输入1

若当前目录下`input.txt`中内容如下：

```
aaabbc
```

### 样例输出1

```
15f0
```

同时程序将压缩结果输出到文件`output.txt`中。

### 样例说明

输入文件中字符的频率为：a为3，b为2，c为1，此外，\0字符将作为压缩文件的结束标志，其出现次数设为1。因此，采用Huffman码生成方法，它们的Huffman编码分别为：

a : 0

b : 10

c : 111

\0 : 110

因此，最终文件压缩结果（按位）为：

`0001010111110000`

将上述结果按字节按十六进制输出到屏幕上则为`15f0`（即`0001010 111110000`的十六进制表示）。

说明：采用Huffman码输出字符序列长度为：1+1+1+2+2+3+3=13（位），由于C语言中输出的最小单位为字节（8位），因此，最后补了三个位0，压缩后实际输出为2个字节。由于文本文件是按ASCII来解释的，因此，以文本方式打开压缩文件将显示乱码（最好用二进制文件查看器来看）。

### 样例输入2

若当前目录下input.txt中内容如下：

```
do not spend all that you have.do not sleep as long as you want.
```

### 样例输出2

```
ea3169146ce9eee6cff4b2a93fe1a5d462d21d9a87c0eb2f3eb2a9cfe6cae
```

同时程序将压缩结果输出到文件`output.txt`中。

### 评分标准

通过所有测试点将得满分。